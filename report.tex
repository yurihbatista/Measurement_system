\documentclass[
    % -- opções da classe memoir --
    article,            % -- tipo de documento --
    a4paper,            % -- tamanho do papel --
    12pt,               % -- tamanho da fonte --
    oneside,            % -- impressão em um lado --
    % -- opções da classe abntex2 --
    %chapter=TITLE,     % -- títulos de capítulos uppercase --
    %section=TITLE,      % -- títulos de seções uppercase --
    %subsection=TITLE,   % -- títulos de subseções uppercase --
    %subsubsection=TITLE,% -- títulos de sub-subseções uppercase --
    % -- opções do pacote babel --
    english,            % -- idioma adicional para hifenização --
    brazil              % -- o último idioma é o principal do documento --
]{abntex2}

% --- PACOTES ---
\usepackage[utf8]{inputenc} % Codificação de caracteres do arquivo.
\usepackage[T1]{fontenc}      % Seleção de codificação de fonte.
\usepackage{lmodern}          % Seleciona a fonte Latin Modern.
\usepackage{fontspec}         % Permite usar fontes do sistema.
\setmainfont{Arial}           % Define Arial como a fonte principal do documento.
\usepackage{graphicx}         % Inclusão de gráficos.
\usepackage{listings}         % Inclusão de código-fonte.
\usepackage{xcolor}           % Cores.
\usepackage{lipsum}           % Para gerar texto de preenchimento.

% --- INFORMAÇÕES DO DOCUMENTO ---
\titulo{Osciloscópio de Quatro Canais Baseado no ESP32}
\autor{Yurih Batista}
\instituicao{
    Universidade Federal de Minas Gerais
    \par
    Curso de Engenharia de Sistemas
}
\data{\today}

% --- CONFIGURAÇÕES DE PACOTES ---

% Configuração do pacote listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% --- PREÂMBULO ---
\begin{document}

% --- Elementos pré-textuais ---
\imprimircapa
\imprimirfolhaderosto

% Resumo em português
\begin{resumo}
Este relatório detalha o desenvolvimento de um osciloscópio de quatro canais utilizando o microcontrolador ESP32. O sistema amostra dois sinais analógicos de alta frequência usando o ADC1 em modo contínuo e dois sinais DC de baixa frequência usando o ADC2 em modo one-shot, disparado por um temporizador. Os dados são transmitidos para um computador hospedeiro via UART, utilizando um protocolo de pacote customizado. Uma interface gráfica (GUI) baseada em Python recebe os dados, analisa os pacotes e exibe os quatro canais em tempo real com a biblioteca PyQtGraph. O processamento no ESP32 é otimizado fixando as tarefas de aquisição de dados de alta e baixa frequência em núcleos de CPU diferentes.
\palavraschave{ESP32, Osciloscópio, ADC, PyQtGraph, Sistemas Embarcados}
\end{resumo}

% Abstract em inglês
\begin{abstract}
This report details the development of a four-channel oscilloscope using an ESP32 microcontroller. The system samples two high-frequency analog signals using the ADC1 in continuous mode and two low-frequency DC signals using ADC2 in one-shot mode, triggered by a timer. The data is transmitted to a host computer via UART using a custom packet protocol. A Python-based graphical user interface (GUI) receives the data, parses the packets, and displays the four channels in real-time using the PyQtGraph library. The processing on the ESP32 is optimized by pinning the high-frequency and low-frequency data acquisition tasks to different CPU cores.
\keywords{ESP32, Oscilloscope, ADC, PyQtGraph, Embedded Systems}
\end{abstract}

% Listas (se necessário)
\listoffigures
\listoflistings
\tableofcontents

% --- Elementos textuais ---
\textual

\section{Introdução}
O objetivo deste projeto é projetar e implementar um sistema de aquisição de dados multicanal de baixo custo para visualização de sinais em tempo real. O sistema aproveita a arquitetura dual-core e os periféricos integrados do ESP32 para amostrar simultaneamente sinais analógicos com diferentes frequências. Este relatório abrange a configuração do hardware, o design do firmware para o ESP32, o protocolo de transferência de dados e a implementação do software de visualização baseado em Python.

\section{Hardware e Software}
\subsection{Hardware}
\begin{itemize}
    \item \textbf{Microcontrolador:} ESP32-DevKitC V1
    \item \textbf{Canais ADC:}
        \begin{itemize}
            \item Canal 0: GPIO34 (ADC1_CHANNEL_6)
            \item Canal 1: GPIO35 (ADC1_CHANNEL_7)
            \item Canal 2: GPIO25 (ADC2_CHANNEL_8)
            \item Canal 3: GPIO26 (ADC2_CHANNEL_9)
        \end{itemize}
\end{itemize}

\subsection{Software}
\begin{itemize}
    \item \textbf{Desenvolvimento do Firmware:} PlatformIO IDE com framework ESP-IDF
    \item \textbf{Desenvolvimento da GUI:} Python 3
    \item \textbf{Bibliotecas:}
        \begin{itemize}
            \item \texttt{pyqtgraph}: Para plotagem de alta performance
            \item \texttt{pyserial}: Para comunicação serial
            \item \texttt{numpy}: Para operações numéricas
        \end{itemize}
\end{itemize}

\section{Implementação}

\subsection{Firmware do ESP32}
O firmware foi escrito em C utilizando o framework ESP-IDF. Ele é projetado para lidar com dois tipos de amostragem ADC concorrentemente.

\subsubsection{Canais de Alta Frequência (ADC1)}
Dois canais são amostrados usando o ADC1 em modo contínuo a 100 kS/s. Os dados são processados em uma tarefa fixada no Core 0 do ESP32.

\subsubsection{Canais de Baixa Frequência (ADC2)}
Outros dois canais são amostrados usando o ADC2 em modo one-shot. Um temporizador de hardware é configurado para disparar a amostragem a 100 Hz. Uma tarefa separada, fixada no Core 1, é responsável por ler e enviar os dados desses canais.

\begin{lstlisting}[language=C, caption={Implementação da Tarefa do ADC2}, label={lst:adc2_task}]
static void adc2_task(void *arg)
{
    while(1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

        int adc_raw[2];
        ESP_ERROR_CHECK(adc_oneshot_read(adc2_handle, ADC2_INPUT_CHANNEL_0, &adc_raw[0]));
        ESP_ERROR_CHECK(adc_oneshot_read(adc2_handle, ADC2_INPUT_CHANNEL_1, &adc_raw[1]));
        
        uint16_t adc_val_0 = (uint16_t)adc_raw[0];
        uint16_t adc_val_1 = (uint16_t)adc_raw[1];

        // Criação do pacote e escrita na UART...
    }
}
\end{lstlisting}

\subsection{Protocolo de Transferência de Dados}
Um protocolo de pacote customizado foi projetado para garantir uma transmissão de dados robusta. Cada pacote tem uma estrutura fixa, conforme mostrado abaixo:
\begin{itemize}
    \item \textbf{Palavra de Início (2 bytes):} \texttt{0xAAAA}
    \item \textbf{ID do Canal (1 byte):} 0, 1, 2, ou 3
    \item \textbf{Tamanho dos Dados (2 bytes):} Comprimento do payload de dados
    \item \textbf{Dados (tamanho variável):} As amostras do ADC
    \item \textbf{Palavra de Fim (2 bytes):} \texttt{0xBBBB}
\end{itemize}

\subsection{GUI em Python}
A GUI foi desenvolvida em Python com PyQtGraph. Ela executa uma thread separada para ler da porta serial, que procura pela estrutura do pacote e coloca os dados em uma fila. A thread principal então lê da fila e atualiza os gráficos. A janela é dividida em duas colunas, com os canais de alta frequência ocupando dois terços da largura e os canais de baixa frequência ocupando o terço restante.

\begin{lstlisting}[language=Python, caption={Leitor Serial em Python}, label={lst:serial_reader}]
def serial_reader(self):
    read_buffer = bytearray()
    while not self.stop_event.is_set():
        # Procura por START_WORD
        # Desempacota o cabeçalho
        # Lê o payload de dados
        # Verifica END_WORD
        # Coloca os dados na fila
        pass
\end{lstlisting}

\section{Resultados}
O sistema exibe com sucesso os quatro canais em tempo real. Os canais de alta frequência são exibidos com um gatilho para estabilizar a forma de onda, enquanto os canais de baixa frequência são exibidos como gráficos simples. Uma captura de tela da aplicação em execução é mostrada na Figura \ref{fig:screenshot}.

\begin{figure}[h]
    \centering
    % \includegraphics[width=0.8\textwidth]{path/to/your/screenshot.png}
    \caption{Captura de tela da GUI do osciloscópio de 4 canais.}
    \fonte{Autor}
    \label{fig:screenshot}
\end{figure}

\section{Conclusão}
Este projeto demonstra uma implementação prática de um sistema de aquisição de dados multicanal usando o ESP32. O uso de dois núcleos e um protocolo de pacote customizado permite a amostragem e visualização simultânea e confiável de sinais com diferentes características. Trabalhos futuros podem incluir a adição de mais canais, a implementação de opções de gatilho mais avançadas e a adição de uma interface baseada na web.

% --- Elementos pós-textuais ---
\bibliography{references.bib}

\end{document}